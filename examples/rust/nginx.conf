daemon off;
error_log /dev/stderr info;
worker_processes auto;
env LD_LIBRARY_PATH;
env RUST_BACKTRACE=full;

events {}

http {
    init_worker_by_lua_block {
        grpc = require("grpc_client")

        grpc.loadfile("helloworld.proto")
        grpc.loadfile("route_guide.proto")
    }

    server {
        listen 20000;

        location /echo {
            content_by_lua_block {
                local cjson = require("cjson")
                local cfg = { name = "hello", value = "world", flag = 200 }
                local demo = ngx.load_nonblocking_ffi("echo", cjson.encode(cfg))
                local ok, res = demo:echo("foobar")
                assert(ok)
                assert(res == "foobar")

                demo:__unload()
                ok, res = demo:echo("foobar")
                assert(not ok)
                ngx.log(ngx.ERR, res)

                ngx.say("ok")
            }
        }

        location /say_hello {
            content_by_lua_block {
                local ok, conn = grpc.connect("http://[::1]:50051")
                assert(ok)

                ngx.update_time()
                local t1 = ngx.now()
                for _ = 1,10000 do
                    local ok, res = conn:unary(
                        "/helloworld.Greeter/SayHello",
                        {name = "foobar"}
                    )
                    assert(ok)
                    assert(res.message == "Hello foobar!")
                end
                ngx.update_time()
                local t2 = ngx.now()
                ngx.say(t2-t1)

                conn:close()

                ngx.say("ok")
            }
        }

        location /get_feature {
            content_by_lua_block {
                local cjson = require("cjson")
                local ok, conn = grpc.connect("http://[::1]:10000")
                assert(ok)

                local ok, res = conn:unary(
                    "/routeguide.RouteGuide/GetFeature",
                    {latitude = 409146138, longitude = -746188906}
                )
                assert(ok)
                ngx.say(cjson.encode(res))

                conn:close()

                ngx.say("ok")
            }
        }

        location /list_features {
            content_by_lua_block {
                local cjson = require("cjson")

                local grpc = ngx.load_nonblocking_ffi("grpc_client")
                local ok, cli = grpc:connect(cjson.encode({cmd = NEW_CONNECTION, key = "http://[::1]:10000"}))
                assert(ok)

                -- A server-to-client streaming RPC.
                local path = "/routeguide.RouteGuide/ListFeatures"
                local ok, stream = grpc:connect(cjson.encode({
                    cmd = NEW_STREAM,
                    key = cli,
                    path = "/routeguide.RouteGuide/ListFeatures",
                }))
                assert(ok)

                local rectangle = {
                    lo = {latitude = 400000000, longitude = -750000000},
                    hi = {latitude = 420000000, longitude = -730000000},
                }
                local ok, res = grpc:call(cjson.encode({
                    cmd = STREAM_SEND,
                    key = stream,
                    payload = ngx.encode_base64(pb:encode(path, rectangle)),
                }))
                assert(ok)

                local ok = grpc:call(cjson.encode({
                    cmd = CLOSE_SEND,
                    key = stream,
                }))
                assert(ok)

                while true do
                    local ok, res = grpc:call(cjson.encode({
                        cmd = STREAM_RECV,
                        key = stream,
                    }))
                    assert(ok)
                    if not res then
                        break
                    end
                    res = pb:decode(path, res)
                    ngx.say(cjson.encode(res))
                end

                local ok = grpc:connect(cjson.encode({cmd = CLOSE_STREAM, key = stream}))
                assert(ok)

                local ok = grpc:remove(cjson.encode({cmd = CLOSE_CONNECTION, key = cli}))
                assert(ok)

                ngx.say("ok")
            }
        }

        location /record_route {
            content_by_lua_block {
                local cjson = require("cjson")

                local grpc = ngx.load_nonblocking_ffi("grpc_client")
                local ok, cli = grpc:connect(cjson.encode({cmd = NEW_CONNECTION, key = "http://[::1]:10000"}))
                assert(ok)

                -- A client-to-server streaming RPC.
                local path = "/routeguide.RouteGuide/RecordRoute"
                local ok, stream = grpc:connect(cjson.encode({
                    cmd = NEW_STREAM,
                    key = cli,
                    path = path,
                }))
                assert(ok)

                for i=1,3 do
                    local point = {latitude = 409146138 + i*100, longitude = -746188906 + i*50}
                    local ok, res = grpc:call(cjson.encode({
                        cmd = STREAM_SEND,
                        key = stream,
                        payload = ngx.encode_base64(pb:encode(path, point)),
                    }))
                    assert(ok)
                end

                local ok = grpc:call(cjson.encode({
                    cmd = CLOSE_SEND,
                    key = stream,
                }))
                assert(ok)

                local ok, res = grpc:call(cjson.encode({
                    cmd = STREAM_RECV,
                    key = stream,
                }))
                assert(ok)
                res = pb:decode(path, res)
                ngx.say(cjson.encode(res))

                local ok, res = grpc:call(cjson.encode({
                    cmd = STREAM_RECV,
                    key = stream,
                }))
                assert(ok and not res)

                local ok = grpc:connect(cjson.encode({cmd = CLOSE_STREAM, key = stream}))
                assert(ok)

                local ok = grpc:remove(cjson.encode({cmd = CLOSE_CONNECTION, key = cli}))
                assert(ok)

                ngx.say("ok")
            }
        }

        location /route_chat {
            content_by_lua_block {
                local cjson = require("cjson")

                local grpc = ngx.load_nonblocking_ffi("grpc_client")
                local ok, cli = grpc:connect(cjson.encode({cmd = NEW_CONNECTION, key = "http://[::1]:10000"}))
                assert(ok)

                -- A Bidirectional streaming RPC.
                local path = "/routeguide.RouteGuide/RouteChat"
                local ok, stream = grpc:connect(cjson.encode({
                    cmd = NEW_STREAM,
                    key = cli,
                    path = path,
                }))
                assert(ok)

                for i=1,3 do
                    local note = {
                        location = {latitude = 409146138 + i*100, longitude = -746188906 + i*50},
                        message = string.format("note-%d", i),
                    }
                    local ok, res = grpc:call(cjson.encode({
                        cmd = STREAM_SEND,
                        key = stream,
                        payload = ngx.encode_base64(pb:encode(path, note)),
                    }))
                    assert(ok)

                    local ok, res = grpc:call(cjson.encode({
                        cmd = STREAM_RECV,
                        key = stream,
                    }))
                    assert(ok)
                    res = pb:decode(path, res)
                    ngx.say(cjson.encode(res))
                end

                local ok = grpc:connect(cjson.encode({cmd = CLOSE_STREAM, key = stream}))
                assert(ok)

                local ok = grpc:remove(cjson.encode({cmd = CLOSE_CONNECTION, key = cli}))
                assert(ok)

                ngx.say("ok")
            }
        }
    }
}
