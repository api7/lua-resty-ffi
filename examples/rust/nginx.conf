daemon off;
error_log /dev/stderr info;
worker_processes auto;
env LD_LIBRARY_PATH;
env RUST_BACKTRACE=full;

events {}

http {
    init_worker_by_lua_block {
        require("protoc").new():loadfile("helloworld.proto")
        require("protoc").new():loadfile("route_guide.proto")

        NEW_CONNECTION = 0
        CLOSE_CONNECTION = 1
        UNARY = 2
        NEW_STREAM = 3
        CLOSE_STREAM = 4
        CLOSE_SEND = 5
        STREAM_SEND = 6
        STREAM_RECV = 7
    }

    server {
        listen 20000;

        location /echo {
            content_by_lua_block {
                local cjson = require("cjson")
                local cfg = { name = "hello", value = "world", flag = 200 }
                local demo = ngx.load_nonblocking_ffi("echo", cjson.encode(cfg))
                local ok, res = demo:echo("foobar")
                assert(ok)
                assert(res == "foobar")

                demo:__unload()
                ok, res = demo:echo("foobar")
                assert(not ok)
                ngx.log(ngx.ERR, res)

                ngx.say("ok")
            }
        }

        location /say_hello {
            content_by_lua_block {
                local pb = require("pb")
                local cjson = require("cjson")

                local grpc = ngx.load_nonblocking_ffi("grpc_client")
                local ok, cli = grpc:connect(cjson.encode({cmd = 0, key = "http://[::1]:50051"}))
                assert(ok)

                local req = {name = "foobar"}

                ngx.update_time()
                local t1 = ngx.now()
                for _ = 1,10000 do
                    local ok, res = grpc:call(cjson.encode({
                        cmd = 2,
                        key = cli,
                        path = "/helloworld.Greeter/SayHello",
                        payload = ngx.encode_base64(pb.encode("helloworld.HelloRequest", req)),
                    }))
                    assert(ok)
                    res = pb.decode("helloworld.HelloReply", res)
                    assert(res.message == "Hello foobar!")
                end
                ngx.update_time()
                local t2 = ngx.now()
                ngx.say(t2-t1)

                local ok = grpc:remove(cjson.encode({cmd = 1, key = cli}))
                assert(ok)

                ngx.say("ok")
            }
        }

        location /get_feature {
            content_by_lua_block {
                local pb = require("pb")
                local cjson = require("cjson")

                local grpc = ngx.load_nonblocking_ffi("grpc_client")
                local ok, cli = grpc:connect(cjson.encode({cmd = NEW_CONNECTION, key = "http://[::1]:10000"}))
                assert(ok)

                -- GetFeature
                local point = {latitude = 409146138, longitude = -746188906}
                local ok, res = grpc:call(cjson.encode({
                    cmd = UNARY,
                    key = cli,
                    path = "/routeguide.RouteGuide/GetFeature",
                    payload = ngx.encode_base64(pb.encode("routeguide.Point", point)),
                }))
                assert(ok)
                res = pb.decode("routeguide.Feature", res)
                ngx.say(cjson.encode(res))

                local ok = grpc:remove(cjson.encode({cmd = CLOSE_CONNECTION, key = cli}))
                assert(ok)

                ngx.say("ok")
            }
        }

        location /list_features {
            content_by_lua_block {
                local pb = require("pb")
                local cjson = require("cjson")

                local grpc = ngx.load_nonblocking_ffi("grpc_client")
                local ok, cli = grpc:connect(cjson.encode({cmd = NEW_CONNECTION, key = "http://[::1]:10000"}))
                assert(ok)

                -- A server-to-client streaming RPC.
                local ok, stream = grpc:connect(cjson.encode({
                    cmd = NEW_STREAM,
                    key = cli,
                    path = "/routeguide.RouteGuide/ListFeatures",
                }))
                assert(ok)

                local rectangle = {
                    lo = {latitude = 400000000, longitude = -750000000},
                    hi = {latitude = 420000000, longitude = -730000000},
                }
                local ok, res = grpc:call(cjson.encode({
                    cmd = STREAM_SEND,
                    key = stream,
                    payload = ngx.encode_base64(pb.encode("routeguide.Rectangle", rectangle)),
                }))
                assert(ok)

                local ok = grpc:call(cjson.encode({
                    cmd = CLOSE_SEND,
                    key = stream,
                }))
                assert(ok)

                while true do
                    local ok, res = grpc:call(cjson.encode({
                        cmd = STREAM_RECV,
                        key = stream,
                    }))
                    assert(ok)
                    if not res then
                        break
                    end
                    res = pb.decode("routeguide.Feature", res)
                    ngx.say(cjson.encode(res))
                end

                local ok = grpc:connect(cjson.encode({cmd = CLOSE_STREAM, key = stream}))
                assert(ok)

                local ok = grpc:remove(cjson.encode({cmd = CLOSE_CONNECTION, key = cli}))
                assert(ok)

                ngx.say("ok")
            }
        }

        location /record_route {
            content_by_lua_block {
                local pb = require("pb")
                local cjson = require("cjson")

                local grpc = ngx.load_nonblocking_ffi("grpc_client")
                local ok, cli = grpc:connect(cjson.encode({cmd = NEW_CONNECTION, key = "http://[::1]:10000"}))
                assert(ok)

                -- A client-to-server streaming RPC.
                local ok, stream = grpc:connect(cjson.encode({
                    cmd = NEW_STREAM,
                    key = cli,
                    path = "/routeguide.RouteGuide/RecordRoute",
                }))
                assert(ok)

                for i=1,3 do
                    local point = {latitude = 409146138 + i*100, longitude = -746188906 + i*50}
                    local ok, res = grpc:call(cjson.encode({
                        cmd = STREAM_SEND,
                        key = stream,
                        payload = ngx.encode_base64(pb.encode("routeguide.Point", point)),
                    }))
                    assert(ok)
                end

                local ok = grpc:call(cjson.encode({
                    cmd = CLOSE_SEND,
                    key = stream,
                }))
                assert(ok)

                local ok, res = grpc:call(cjson.encode({
                    cmd = STREAM_RECV,
                    key = stream,
                }))
                assert(ok)
                res = pb.decode("routeguide.RouteSummary", res)
                ngx.say(cjson.encode(res))

                local ok, res = grpc:call(cjson.encode({
                    cmd = STREAM_RECV,
                    key = stream,
                }))
                assert(ok and not res)

                local ok = grpc:connect(cjson.encode({cmd = CLOSE_STREAM, key = stream}))
                assert(ok)

                local ok = grpc:remove(cjson.encode({cmd = CLOSE_CONNECTION, key = cli}))
                assert(ok)

                ngx.say("ok")
            }
        }

        location /route_chat {
            content_by_lua_block {
                local pb = require("pb")
                local cjson = require("cjson")

                local grpc = ngx.load_nonblocking_ffi("grpc_client")
                local ok, cli = grpc:connect(cjson.encode({cmd = NEW_CONNECTION, key = "http://[::1]:10000"}))
                assert(ok)

                -- A Bidirectional streaming RPC.
                local ok, stream = grpc:connect(cjson.encode({
                    cmd = NEW_STREAM,
                    key = cli,
                    path = "/routeguide.RouteGuide/RouteChat",
                }))
                assert(ok)

                for i=1,3 do
                    local note = {
                        location = {latitude = 409146138 + i*100, longitude = -746188906 + i*50},
                        message = string.format("note-%d", i),
                    }
                    local ok, res = grpc:call(cjson.encode({
                        cmd = STREAM_SEND,
                        key = stream,
                        payload = ngx.encode_base64(pb.encode("routeguide.RouteNote", note)),
                    }))
                    assert(ok)

                    local ok, res = grpc:call(cjson.encode({
                        cmd = STREAM_RECV,
                        key = stream,
                    }))
                    assert(ok)
                    res = pb.decode("routeguide.RouteNote", res)
                    ngx.say(cjson.encode(res))
                end

                local ok = grpc:connect(cjson.encode({cmd = CLOSE_STREAM, key = stream}))
                assert(ok)

                local ok = grpc:remove(cjson.encode({cmd = CLOSE_CONNECTION, key = cli}))
                assert(ok)

                ngx.say("ok")
            }
        }
    }
}
